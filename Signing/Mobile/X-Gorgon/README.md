# X-Gorgon 0404 & X-Khronos

Two of the five current TikTok's security headers in their mobile android API are X-Gorgon & X-Khronos. These two are used by TikTok to authenticate and secure API requests & were the first two ever added.

- X-Gorgon: This header is created by hashing key components and combining them with a version and timestamp. It ensures the validity and integrity of requests to TikTok's servers.

- X-Khronos: This is a hexadecimal timestamp representing the time at which the request is made.

### Hashed String Example: 
- Params Hash -> 9336ebf25087d91c818ee6e9ec29f8c1 
- No Data -> 00000000000000000000000000000  
- No Cookies -> 00000000000000000000000000000000000

### Encrypted String example:
- Version -> 0404
- Static hash -> b0d30000
- Encrypted hash string -> 3f2892cbeb57387ccee15dbc3694a6f7df5311c6

TikTok decrypts the X-Gorgon header to validate the request. If the decryption is successful, the request is considered valid and access to the API is granted; otherwise, an empty response or an error status code may be returned.

### Base String & Encryption Key Generation:

- The base string is generated by concatenating MD5 hashes of URL parameters, post data, and cookies, along with a hexadecimal timestamp.
- If either the data or cookies are not provided, 32 zeros are used in place of their hashes.
- This base string is then converted to a hex list and serves as the encryption key.
- The header is contructed by using the version (0404), a static hash (b0d30000), and the encrypted hash string. It also includes the X-Khronos header with the current timestamp.

```py
def get_value(self) -> dict:
    gorgon = self.encrypt(
        "".join(
            hashlib.md5(value.encode()).hexdigest()
            if value
            else "00000000000000000000000000000000"
            for value in [self.params, self.data, self.cookies]
        )
    )
    return {
        "X-Gorgon": f"0404b0d30000{gorgon}",
        "X-Khronos": str(int(time.time()))
    }

```
  
### Base String Encryption:

The encrypt method takes the base string, processes it, applies bitwise operations and XOR with a predefined encryption key, and then converts the resulting integers to a hexadecimal string, which represents the encrypted version of the base string.

```py
@staticmethod
def encrypt(data: str) -> str:
    unix = int(time.time())
    length = 0x14
    key = [
        0xDF,
        0x77,
        0xB9,
        0x40,
        0xB9,
        0x9B,
        0x84,
        0x83,
        0xD1,
        0xB9,
        0xCB,
        0xD1,
        0xF7,
        0xC2,
        0xB9,
        0x85,
        0xC3,
        0xD0,
        0xFB,
        0xC3,
    ]


    param_list = [
        int(data[8 * i : 8 * (i + 1)][j * 2 : (j + 1) * 2], 16)
        for i in range(3)
        for j in range(4)
    ]
    param_list.extend([0x0, 0x6, 0xB, 0x1C])

    unix_bytes = unix.to_bytes(4, byteorder="big")
    param_list.extend(unix_bytes)

    eor_result_list = [A ^ B for A, B in zip(param_list, key)]

    for i in range(length):
        eor_result_list[i] = (~eor_result_list[i] ^ length) & 0xFF

    return "".join(f"{param:02x}" for param in eor_result_list)
```

## Example Usage:

```py
from signature import Signature

signer = Signature(params="", data="", cookies="").get_value()

print(f"X-Gorgon: {signer['X-Gorgon']} X-Khronos: {signer['X-Khronos']}")
```
